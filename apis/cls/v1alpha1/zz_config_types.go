/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ConfigInitParameters struct {

	// Collection path blocklist.
	// Collection path blocklist.
	ExcludePaths []ExcludePathsInitParameters `json:"excludePaths,omitempty" tf:"exclude_paths,omitempty"`

	// Extraction rule. If ExtractRule is set, LogType must be set.
	// Extraction rule. If ExtractRule is set, LogType must be set.
	ExtractRule []ExtractRuleInitParameters `json:"extractRule,omitempty" tf:"extract_rule,omitempty"`

	// Type of the log to be collected. Valid values: json_log: log in JSON format; delimiter_log: log in delimited format; minimalist_log: minimalist log; multiline_log: log in multi-line format; fullregex_log: log in full regex format. Default value: minimalist_log.
	// Type of the log to be collected. Valid values: json_log: log in JSON format; delimiter_log: log in delimited format; minimalist_log: minimalist log; multiline_log: log in multi-line format; fullregex_log: log in full regex format. Default value: minimalist_log.
	LogType *string `json:"logType,omitempty" tf:"log_type,omitempty"`

	// Collection configuration name.
	// Collection configuration name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Log topic ID (TopicId) of collection configuration.
	// Log topic ID (TopicId) of collection configuration.
	Output *string `json:"output,omitempty" tf:"output,omitempty"`

	// Log collection path containing the filename. Required for document collection.
	// Log collection path containing the filename. Required for document collection.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Custom collection rule, which is a serialized JSON string. Required when LogType is user_define_log.
	// Custom collection rule, which is a serialized JSON string. Required when LogType is user_define_log.
	UserDefineRule *string `json:"userDefineRule,omitempty" tf:"user_define_rule,omitempty"`
}

type ConfigObservation struct {

	// Collection path blocklist.
	// Collection path blocklist.
	ExcludePaths []ExcludePathsObservation `json:"excludePaths,omitempty" tf:"exclude_paths,omitempty"`

	// Extraction rule. If ExtractRule is set, LogType must be set.
	// Extraction rule. If ExtractRule is set, LogType must be set.
	ExtractRule []ExtractRuleObservation `json:"extractRule,omitempty" tf:"extract_rule,omitempty"`

	// ID of the resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Type of the log to be collected. Valid values: json_log: log in JSON format; delimiter_log: log in delimited format; minimalist_log: minimalist log; multiline_log: log in multi-line format; fullregex_log: log in full regex format. Default value: minimalist_log.
	// Type of the log to be collected. Valid values: json_log: log in JSON format; delimiter_log: log in delimited format; minimalist_log: minimalist log; multiline_log: log in multi-line format; fullregex_log: log in full regex format. Default value: minimalist_log.
	LogType *string `json:"logType,omitempty" tf:"log_type,omitempty"`

	// Collection configuration name.
	// Collection configuration name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Log topic ID (TopicId) of collection configuration.
	// Log topic ID (TopicId) of collection configuration.
	Output *string `json:"output,omitempty" tf:"output,omitempty"`

	// Log collection path containing the filename. Required for document collection.
	// Log collection path containing the filename. Required for document collection.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Custom collection rule, which is a serialized JSON string. Required when LogType is user_define_log.
	// Custom collection rule, which is a serialized JSON string. Required when LogType is user_define_log.
	UserDefineRule *string `json:"userDefineRule,omitempty" tf:"user_define_rule,omitempty"`
}

type ConfigParameters struct {

	// Collection path blocklist.
	// Collection path blocklist.
	// +kubebuilder:validation:Optional
	ExcludePaths []ExcludePathsParameters `json:"excludePaths,omitempty" tf:"exclude_paths,omitempty"`

	// Extraction rule. If ExtractRule is set, LogType must be set.
	// Extraction rule. If ExtractRule is set, LogType must be set.
	// +kubebuilder:validation:Optional
	ExtractRule []ExtractRuleParameters `json:"extractRule,omitempty" tf:"extract_rule,omitempty"`

	// Type of the log to be collected. Valid values: json_log: log in JSON format; delimiter_log: log in delimited format; minimalist_log: minimalist log; multiline_log: log in multi-line format; fullregex_log: log in full regex format. Default value: minimalist_log.
	// Type of the log to be collected. Valid values: json_log: log in JSON format; delimiter_log: log in delimited format; minimalist_log: minimalist log; multiline_log: log in multi-line format; fullregex_log: log in full regex format. Default value: minimalist_log.
	// +kubebuilder:validation:Optional
	LogType *string `json:"logType,omitempty" tf:"log_type,omitempty"`

	// Collection configuration name.
	// Collection configuration name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Log topic ID (TopicId) of collection configuration.
	// Log topic ID (TopicId) of collection configuration.
	// +kubebuilder:validation:Optional
	Output *string `json:"output,omitempty" tf:"output,omitempty"`

	// Log collection path containing the filename. Required for document collection.
	// Log collection path containing the filename. Required for document collection.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Custom collection rule, which is a serialized JSON string. Required when LogType is user_define_log.
	// Custom collection rule, which is a serialized JSON string. Required when LogType is user_define_log.
	// +kubebuilder:validation:Optional
	UserDefineRule *string `json:"userDefineRule,omitempty" tf:"user_define_rule,omitempty"`
}

type ExcludePathsInitParameters struct {

	// Type. Valid values: File, Path.
	// Type. Valid values: File, Path.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Specific content corresponding to Type.
	// Specific content corresponding to Type.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ExcludePathsObservation struct {

	// Type. Valid values: File, Path.
	// Type. Valid values: File, Path.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Specific content corresponding to Type.
	// Specific content corresponding to Type.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ExcludePathsParameters struct {

	// Type. Valid values: File, Path.
	// Type. Valid values: File, Path.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Specific content corresponding to Type.
	// Specific content corresponding to Type.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ExtractRuleInitParameters struct {

	// syslog system log collection specifies the address and port that the collector listens to. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
	// syslog system log collection specifies the address and port that the collector listens to. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
	// Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
	Backtracking *float64 `json:"backtracking,omitempty" tf:"backtracking,omitempty"`

	// First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
	// First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
	BeginRegex *string `json:"beginRegex,omitempty" tf:"begin_regex,omitempty"`

	// Delimiter for delimited log, which is valid only if log_type is delimiter_log.
	// Delimiter for delimited log, which is valid only if log_type is delimiter_log.
	Delimiter *string `json:"delimiter,omitempty" tf:"delimiter,omitempty"`

	// Log keys to be filtered and the corresponding regex.
	// Log keys to be filtered and the corresponding regex.
	FilterKeyRegex []FilterKeyRegexInitParameters `json:"filterKeyRegex,omitempty" tf:"filter_key_regex,omitempty"`

	// GBK encoding. Default 0. Note: - Currently, when the value is 0, it means UTF-8 encoding.
	// GBK encoding. Default 0. Note: - Currently, when the value is 0, it means UTF-8 encoding.
	IsGbk *float64 `json:"isGbk,omitempty" tf:"is_gbk,omitempty"`

	// standard json. Default 0.
	// standard json. Default 0.
	JSONStandard *float64 `json:"jsonStandard,omitempty" tf:"json_standard,omitempty"`

	// Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
	// Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
	// +listType=set
	Keys []*string `json:"keys,omitempty" tf:"keys,omitempty"`

	// Full log matching rule, which is valid only if log_type is fullregex_log.
	// Full log matching rule, which is valid only if log_type is fullregex_log.
	LogRegex *string `json:"logRegex,omitempty" tf:"log_regex,omitempty"`

	// metadata tags. Note: - Required when MetadataType is 2. - COS import does not support this field.
	// metadata tags. Note: - Required when MetadataType is 2. - COS import does not support this field.
	MetaTags []MetaTagsInitParameters `json:"metaTags,omitempty" tf:"meta_tags,omitempty"`

	// metadata type. 0: Do not use metadata information; 1: Use machine group metadata; 2: Use user-defined metadata; 3: Use collection configuration path. Note: COS import does not support this field.
	// metadata type. 0: Do not use metadata information; 1: Use machine group metadata; 2: Use user-defined metadata; 3: Use collection configuration path. Note: COS import does not support this field.
	MetadataType *float64 `json:"metadataType,omitempty" tf:"metadata_type,omitempty"`

	// parse protocol. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
	// parse protocol. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
	ParseProtocol *string `json:"parseProtocol,omitempty" tf:"parse_protocol,omitempty"`

	// metadata path regex.
	// metadata path regex.
	PathRegex *string `json:"pathRegex,omitempty" tf:"path_regex,omitempty"`

	// syslog protocol, tcp or udp. The value can be tcp or udp. It is effective only when LogType is service_syslog. Other types do not need to be filled in.
	// syslog protocol, tcp or udp. The value can be tcp or udp. It is effective only when LogType is service_syslog. Other types do not need to be filled in.
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
	// Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
	TimeFormat *string `json:"timeFormat,omitempty" tf:"time_format,omitempty"`

	// Time field key name. time_key and time_format must appear in pair.
	// Time field key name. time_key and time_format must appear in pair.
	TimeKey *string `json:"timeKey,omitempty" tf:"time_key,omitempty"`

	// Unmatched log key. Required when UnMatchUpLoadSwitch is true.
	// Unmatched log key. Required when UnMatchUpLoadSwitch is true.
	UnMatchLogKey *string `json:"unMatchLogKey,omitempty" tf:"un_match_log_key,omitempty"`

	// Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
	// Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
	UnMatchUpLoadSwitch *bool `json:"unMatchUpLoadSwitch,omitempty" tf:"un_match_up_load_switch,omitempty"`
}

type ExtractRuleObservation struct {

	// syslog system log collection specifies the address and port that the collector listens to. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
	// syslog system log collection specifies the address and port that the collector listens to. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
	// Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
	Backtracking *float64 `json:"backtracking,omitempty" tf:"backtracking,omitempty"`

	// First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
	// First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
	BeginRegex *string `json:"beginRegex,omitempty" tf:"begin_regex,omitempty"`

	// Delimiter for delimited log, which is valid only if log_type is delimiter_log.
	// Delimiter for delimited log, which is valid only if log_type is delimiter_log.
	Delimiter *string `json:"delimiter,omitempty" tf:"delimiter,omitempty"`

	// Log keys to be filtered and the corresponding regex.
	// Log keys to be filtered and the corresponding regex.
	FilterKeyRegex []FilterKeyRegexObservation `json:"filterKeyRegex,omitempty" tf:"filter_key_regex,omitempty"`

	// GBK encoding. Default 0. Note: - Currently, when the value is 0, it means UTF-8 encoding.
	// GBK encoding. Default 0. Note: - Currently, when the value is 0, it means UTF-8 encoding.
	IsGbk *float64 `json:"isGbk,omitempty" tf:"is_gbk,omitempty"`

	// standard json. Default 0.
	// standard json. Default 0.
	JSONStandard *float64 `json:"jsonStandard,omitempty" tf:"json_standard,omitempty"`

	// Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
	// Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
	// +listType=set
	Keys []*string `json:"keys,omitempty" tf:"keys,omitempty"`

	// Full log matching rule, which is valid only if log_type is fullregex_log.
	// Full log matching rule, which is valid only if log_type is fullregex_log.
	LogRegex *string `json:"logRegex,omitempty" tf:"log_regex,omitempty"`

	// metadata tags. Note: - Required when MetadataType is 2. - COS import does not support this field.
	// metadata tags. Note: - Required when MetadataType is 2. - COS import does not support this field.
	MetaTags []MetaTagsObservation `json:"metaTags,omitempty" tf:"meta_tags,omitempty"`

	// metadata type. 0: Do not use metadata information; 1: Use machine group metadata; 2: Use user-defined metadata; 3: Use collection configuration path. Note: COS import does not support this field.
	// metadata type. 0: Do not use metadata information; 1: Use machine group metadata; 2: Use user-defined metadata; 3: Use collection configuration path. Note: COS import does not support this field.
	MetadataType *float64 `json:"metadataType,omitempty" tf:"metadata_type,omitempty"`

	// parse protocol. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
	// parse protocol. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
	ParseProtocol *string `json:"parseProtocol,omitempty" tf:"parse_protocol,omitempty"`

	// metadata path regex.
	// metadata path regex.
	PathRegex *string `json:"pathRegex,omitempty" tf:"path_regex,omitempty"`

	// syslog protocol, tcp or udp. The value can be tcp or udp. It is effective only when LogType is service_syslog. Other types do not need to be filled in.
	// syslog protocol, tcp or udp. The value can be tcp or udp. It is effective only when LogType is service_syslog. Other types do not need to be filled in.
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
	// Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
	TimeFormat *string `json:"timeFormat,omitempty" tf:"time_format,omitempty"`

	// Time field key name. time_key and time_format must appear in pair.
	// Time field key name. time_key and time_format must appear in pair.
	TimeKey *string `json:"timeKey,omitempty" tf:"time_key,omitempty"`

	// Unmatched log key. Required when UnMatchUpLoadSwitch is true.
	// Unmatched log key. Required when UnMatchUpLoadSwitch is true.
	UnMatchLogKey *string `json:"unMatchLogKey,omitempty" tf:"un_match_log_key,omitempty"`

	// Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
	// Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
	UnMatchUpLoadSwitch *bool `json:"unMatchUpLoadSwitch,omitempty" tf:"un_match_up_load_switch,omitempty"`
}

type ExtractRuleParameters struct {

	// syslog system log collection specifies the address and port that the collector listens to. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
	// syslog system log collection specifies the address and port that the collector listens to. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
	// Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
	// +kubebuilder:validation:Optional
	Backtracking *float64 `json:"backtracking,omitempty" tf:"backtracking,omitempty"`

	// First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
	// First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
	// +kubebuilder:validation:Optional
	BeginRegex *string `json:"beginRegex,omitempty" tf:"begin_regex,omitempty"`

	// Delimiter for delimited log, which is valid only if log_type is delimiter_log.
	// Delimiter for delimited log, which is valid only if log_type is delimiter_log.
	// +kubebuilder:validation:Optional
	Delimiter *string `json:"delimiter,omitempty" tf:"delimiter,omitempty"`

	// Log keys to be filtered and the corresponding regex.
	// Log keys to be filtered and the corresponding regex.
	// +kubebuilder:validation:Optional
	FilterKeyRegex []FilterKeyRegexParameters `json:"filterKeyRegex,omitempty" tf:"filter_key_regex,omitempty"`

	// GBK encoding. Default 0. Note: - Currently, when the value is 0, it means UTF-8 encoding.
	// GBK encoding. Default 0. Note: - Currently, when the value is 0, it means UTF-8 encoding.
	// +kubebuilder:validation:Optional
	IsGbk *float64 `json:"isGbk,omitempty" tf:"is_gbk,omitempty"`

	// standard json. Default 0.
	// standard json. Default 0.
	// +kubebuilder:validation:Optional
	JSONStandard *float64 `json:"jsonStandard,omitempty" tf:"json_standard,omitempty"`

	// Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
	// Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
	// +kubebuilder:validation:Optional
	// +listType=set
	Keys []*string `json:"keys,omitempty" tf:"keys,omitempty"`

	// Full log matching rule, which is valid only if log_type is fullregex_log.
	// Full log matching rule, which is valid only if log_type is fullregex_log.
	// +kubebuilder:validation:Optional
	LogRegex *string `json:"logRegex,omitempty" tf:"log_regex,omitempty"`

	// metadata tags. Note: - Required when MetadataType is 2. - COS import does not support this field.
	// metadata tags. Note: - Required when MetadataType is 2. - COS import does not support this field.
	// +kubebuilder:validation:Optional
	MetaTags []MetaTagsParameters `json:"metaTags,omitempty" tf:"meta_tags,omitempty"`

	// metadata type. 0: Do not use metadata information; 1: Use machine group metadata; 2: Use user-defined metadata; 3: Use collection configuration path. Note: COS import does not support this field.
	// metadata type. 0: Do not use metadata information; 1: Use machine group metadata; 2: Use user-defined metadata; 3: Use collection configuration path. Note: COS import does not support this field.
	// +kubebuilder:validation:Optional
	MetadataType *float64 `json:"metadataType,omitempty" tf:"metadata_type,omitempty"`

	// parse protocol. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
	// parse protocol. This parameter is only valid when LogType is service_syslog. It does not need to be filled in for other types.
	// +kubebuilder:validation:Optional
	ParseProtocol *string `json:"parseProtocol,omitempty" tf:"parse_protocol,omitempty"`

	// metadata path regex.
	// metadata path regex.
	// +kubebuilder:validation:Optional
	PathRegex *string `json:"pathRegex,omitempty" tf:"path_regex,omitempty"`

	// syslog protocol, tcp or udp. The value can be tcp or udp. It is effective only when LogType is service_syslog. Other types do not need to be filled in.
	// syslog protocol, tcp or udp. The value can be tcp or udp. It is effective only when LogType is service_syslog. Other types do not need to be filled in.
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
	// Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
	// +kubebuilder:validation:Optional
	TimeFormat *string `json:"timeFormat,omitempty" tf:"time_format,omitempty"`

	// Time field key name. time_key and time_format must appear in pair.
	// Time field key name. time_key and time_format must appear in pair.
	// +kubebuilder:validation:Optional
	TimeKey *string `json:"timeKey,omitempty" tf:"time_key,omitempty"`

	// Unmatched log key. Required when UnMatchUpLoadSwitch is true.
	// Unmatched log key. Required when UnMatchUpLoadSwitch is true.
	// +kubebuilder:validation:Optional
	UnMatchLogKey *string `json:"unMatchLogKey,omitempty" tf:"un_match_log_key,omitempty"`

	// Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
	// Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
	// +kubebuilder:validation:Optional
	UnMatchUpLoadSwitch *bool `json:"unMatchUpLoadSwitch,omitempty" tf:"un_match_up_load_switch,omitempty"`
}

type FilterKeyRegexInitParameters struct {

	// Log key to be filtered.
	// Log key to be filtered.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Filter rule regex corresponding to key.
	// Filter rule regex corresponding to key.
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`
}

type FilterKeyRegexObservation struct {

	// Log key to be filtered.
	// Log key to be filtered.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Filter rule regex corresponding to key.
	// Filter rule regex corresponding to key.
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`
}

type FilterKeyRegexParameters struct {

	// Log key to be filtered.
	// Log key to be filtered.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Filter rule regex corresponding to key.
	// Filter rule regex corresponding to key.
	// +kubebuilder:validation:Optional
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`
}

type MetaTagsInitParameters struct {

	// Log key to be filtered.
	// tag key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Specific content corresponding to Type.
	// tag value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MetaTagsObservation struct {

	// Log key to be filtered.
	// tag key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Specific content corresponding to Type.
	// tag value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MetaTagsParameters struct {

	// Log key to be filtered.
	// tag key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Specific content corresponding to Type.
	// tag value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

// ConfigSpec defines the desired state of Config
type ConfigSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ConfigParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ConfigInitParameters `json:"initProvider,omitempty"`
}

// ConfigStatus defines the observed state of Config.
type ConfigStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ConfigObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Config is the Schema for the Configs API. Provides a resource to create a cls config
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloud}
type Config struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.extractRule) || (has(self.initProvider) && has(self.initProvider.extractRule))",message="spec.forProvider.extractRule is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   ConfigSpec   `json:"spec"`
	Status ConfigStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ConfigList contains a list of Configs
type ConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Config `json:"items"`
}

// Repository type metadata.
var (
	Config_Kind             = "Config"
	Config_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Config_Kind}.String()
	Config_KindAPIVersion   = Config_Kind + "." + CRDGroupVersion.String()
	Config_GroupVersionKind = CRDGroupVersion.WithKind(Config_Kind)
)

func init() {
	SchemeBuilder.Register(&Config{}, &ConfigList{})
}
